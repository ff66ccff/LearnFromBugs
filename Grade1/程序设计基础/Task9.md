# Task9
# 直方图均衡化

## 描述

灰度直方图是一种用来表示图像中每一灰度等级出现的频率的统计关系的表示方法。灰度直方图是灰度级的函数，其横坐标是灰度级，纵坐标是该灰度级出现的频率。

直方图均衡化是对图像进行非线性拉伸的一种方法，它可以使图像的灰度范围拉开，增大反差，使图像细节清晰，以达到增强的目的。

算法思路是根据图像本身的灰度直方图分布重新分配图像像素灰度值，使一定灰度范围内的像素值的数量大致相等，这样使得原来直方图中间的峰值部分对比度增强，两侧低谷部分对比度降低，输出图像的灰度直方图相对平坦，扩大了图像灰度的动态范围。

算法流程：

假设图像为 $m×n$ 个像素，像素灰度值范围为 $0∼63$，其中最大的灰度值为 $63$，总的像素数量为 $m×n$：

1. 统计每个灰度级像素点的个数。
2. 计算灰度分布概率，即该灰度值的像素数量除以总的像素数量($m×n$)。
3. 计算累计分布，即灰度值小于等于本灰度的分布概率之和。
4. 计算映射灰度并取整，映射灰度等于累计分布乘以灰度最大值(本例中为$63$)，取整采用四舍五入。
5. 将灰度进行映射，即将计算出的映射灰度替换原灰度值。

## 输入

第一行输入 $m,n$ $(3≤m,n≤20)$，表示输入的图像的行和列的数量。

随后输入 $m×n$ 的二维数组代表图像的像素灰度值，图像像素灰度值范围为 $0∼63$。

## 输出

输出灰度映射后的二维数组。

## 样例

### 输入
```
4 4
12 35 54 60
35 60 60 54
12 54 12 12
12 12 54 54
```

### 输出
```
24 32 51 63
32 63 63 51
24 51 24 24
24 24 51 51
```

## 解答

根据描述中的算法流程，首先统计各个灰度值出现的次数，然后计算每个灰度值的分布概率和累计分布概率，最后根据累计分布概率计算映射后的灰度值并四舍五入。注意灰度值范围为0~63，需要统计这64个灰度值的出现情况。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int m, n;
	cin >> m >> n; // m行n列
	int sums = m * n; // 总像素点数
	vector<double> times(64, 0); // 记录各个灰度出现次数
	vector<vector<int>> arr(m, vector<int>(n)); // 二维数组存储原始图像
	
	// 读取输入并统计灰度值出现次数
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			cin >> arr[i][j];
			times[arr[i][j]] += 1;
		}
	}
	
	vector<int> transform(64); // 记录每个灰度值映射后的值
	double max_pixel = 63.0; // 最大灰度值
	double probablity_sum = 0.0; // 累计分布概率
	
	// 计算每个灰度值的映射值
	for (int i = 0; i < 64; i++) {
		double probablity = times[i] / sums; // 分布概率
		probablity_sum += probablity; // 累计分布概率
		transform[i] = round(max_pixel * probablity_sum); // 四舍五入取整
	}
	
	// 输出映射后的图像
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			cout << transform[arr[i][j]];
			if (j != n - 1) {
				cout << " ";
			}
		}
		cout << endl;
	}
	
	return 0;
}
```

---